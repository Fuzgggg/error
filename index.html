<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Video Chat + Switch Camera</title>
  <style>
    body { font-family: Arial, sans-serif; background: #111; color: #eee; text-align: center; }
    #videos { display: flex; justify-content: center; gap: 10px; margin: 20px; }
    video { width: 45%; background: #000; border-radius: 10px; }
    #chat { width: 80%; max-width: 500px; margin: 20px auto; background: #222; padding: 10px; border-radius: 10px; }
    #messages { height: 200px; overflow-y: auto; text-align: left; margin-bottom: 10px; }
    input, button { padding: 10px; margin: 5px; border-radius: 5px; border: none; }
    button { background: #0a84ff; color: #fff; cursor: pointer; }
    button:hover { background: #006edc; }
  </style>
</head>
<body>
  <h2>📹 Video Chat</h2>

  <div id="videos">
    <video id="localVideo" autoplay playsinline muted></video>
    <video id="remoteVideo" autoplay playsinline></video>
  </div>

  <div>
    <input type="text" id="roomInput" placeholder="Room Code">
    <button onclick="createRoom()">Create Room</button>
    <button onclick="joinRoom()">Join Room</button>
    <button onclick="switchToFront()">Front Camera</button>
    <button onclick="switchToBack()">Back Camera</button>
  </div>

  <div id="chat">
    <div id="messages"></div>
    <input type="text" id="chatInput" placeholder="Type a message...">
    <button onclick="sendMessage()">Send</button>
  </div>

  <script>
    let localStream, peerConnection, dataChannel;
    let ws, roomCode;
    const playerName = "Player" + Math.floor(Math.random() * 1000);

    const servers = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };

    // 📹 Start default camera (front)
    async function startCamera(deviceId=null){
      if(localStream){ localStream.getTracks().forEach(t=>t.stop()); }
      let constraints = { audio:true, video: deviceId ? { deviceId: { exact: deviceId } } : { facingMode: "user" } };
      localStream = await navigator.mediaDevices.getUserMedia(constraints);
      document.getElementById("localVideo").srcObject = localStream;
      if(peerConnection){
        const sender = peerConnection.getSenders().find(s=>s.track.kind==="video");
        if(sender) sender.replaceTrack(localStream.getVideoTracks()[0]);
      }
    }

    // 🔄 Switch to front camera
    async function switchToFront(){
      await startCamera(null); // default user-facing
      addMessage("✅ Front Camera", "System");
    }

    // 🔄 Switch to back camera
    async function switchToBack(){
      const devices = await navigator.mediaDevices.enumerateDevices();
      const backCam = devices.find(d => d.kind==="videoinput" && d.label.toLowerCase().includes("back"));
      if(backCam){ await startCamera(backCam.deviceId); addMessage("✅ Back Camera", "System"); }
      else { addMessage("❌ Back camera not found", "System"); }
    }

    // 🟢 Create room
    function createRoom(){
      roomCode = Math.random().toString(36).substr(2,6).toUpperCase();
      connectWS();
      addMessage("Room created: " + roomCode, "System");
      document.getElementById("roomInput").value = roomCode;
    }

    // 🔵 Join room
    function joinRoom(){
      roomCode = document.getElementById("roomInput").value.trim();
      if(!roomCode){ alert("Enter room code"); return; }
      connectWS();
    }

    // 🌐 WebSocket signaling
    function connectWS(){
      ws = new WebSocket("wss://ws.postman-echo.com/raw");
      ws.onopen = async ()=>{
        addMessage("Connected to signaling server","System");
        ws.send(JSON.stringify({join:roomCode, name:playerName}));
        await startCamera();
        makePeer();
      };
      ws.onmessage = async (msg)=>{
        const data = JSON.parse(msg.data);
        if(data.offer){
          await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
          const answer = await peerConnection.createAnswer();
          await peerConnection.setLocalDescription(answer);
          ws.send(JSON.stringify({answer, room:roomCode}));
        } else if(data.answer){
          await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
        } else if(data.candidate){
          try{ await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate)); }catch(e){}
        }
      };
    }

    // 🤝 Peer connection
    function makePeer(){
      peerConnection = new RTCPeerConnection(servers);
      localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));
      peerConnection.ontrack = e => { document.getElementById("remoteVideo").srcObject = e.streams[0]; };
      dataChannel = peerConnection.createDataChannel("chat");
      dataChannel.onmessage = e => addMessage(e.data);
      peerConnection.ondatachannel = e => { e.channel.onmessage = ev => addMessage(ev.data); };
      peerConnection.onicecandidate = e => { if(e.candidate) ws.send(JSON.stringify({candidate:e.candidate, room:roomCode})); };
      if(document.getElementById("roomInput").value.trim()===roomCode){
        peerConnection.createOffer().then(o=>{ peerConnection.setLocalDescription(o); ws.send(JSON.stringify({offer:o, room:roomCode})); });
      }
    }

    // 💬 Chat
    function sendMessage(){
      const text = document.getElementById("chatInput").value;
      if(!text) return;
      const msg = playerName + ": " + text;
      addMessage(msg);
      if(dataChannel) dataChannel.send(msg);
      document.getElementById("chatInput").value="";
    }
    function addMessage(msg,from=""){ document.getElementById("messages").innerHTML += `<div><b>${from}</b> ${msg}</div>`; }
  </script>
</body>
</html>
